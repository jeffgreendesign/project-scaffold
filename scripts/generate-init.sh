#!/bin/bash
# ============================================================================
# generate-init.sh — Build init.sh from scaffold/ contents
# ============================================================================
# Reads all files in scaffold/ and generates a single-file distribution
# script (init.sh) that inlines all content using heredocs.
#
# Usage:
#   ./scripts/generate-init.sh
#
# Output:
#   scripts/init.sh (overwritten each run)
# ============================================================================
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_DIR="$(dirname "$SCRIPT_DIR")"
SCAFFOLD_DIR="$REPO_DIR/scaffold"
OUTPUT="$SCRIPT_DIR/init.sh"

echo "Generating init.sh from scaffold/ contents..."

# Start building the init.sh file
cat > "$OUTPUT" << 'HEADER'
#!/bin/bash
# ============================================================================
# init.sh — Single-file project scaffold distribution
# ============================================================================
# Generated by generate-init.sh — DO NOT EDIT DIRECTLY.
# Regenerate with: ./scripts/generate-init.sh
#
# This script creates all scaffold files in the current directory (or a
# specified target directory). It's the "compiled" version of scaffold/ —
# a single script you can curl | bash or copy-paste without cloning the repo.
#
# Usage:
#   ./scripts/init.sh [target-directory]
#   curl -sL <url>/init.sh | bash
# ============================================================================
set -euo pipefail

TARGET_DIR="${1:-.}"
mkdir -p "$TARGET_DIR"
TARGET_DIR="$(cd "$TARGET_DIR" && pwd)"

echo "Initializing project scaffold in $TARGET_DIR..."
echo ""

# Detect package manager
detect_package_manager() {
  if [ -f "$TARGET_DIR/pnpm-lock.yaml" ]; then
    echo "pnpm"
  elif [ -f "$TARGET_DIR/yarn.lock" ]; then
    echo "yarn"
  elif [ -f "$TARGET_DIR/package-lock.json" ]; then
    echo "npm"
  else
    echo "npm"
  fi
}

PKG_MANAGER=$(detect_package_manager)
echo "Detected package manager: $PKG_MANAGER"

# Helper: write a file, prompting before overwriting
write_file() {
  local filepath="$TARGET_DIR/$1"
  local dirpath
  dirpath="$(dirname "$filepath")"
  mkdir -p "$dirpath"

  if [ -f "$filepath" ]; then
    if [ -t 0 ]; then
      # Interactive — prompt via terminal
      echo -n "  File exists: $1 — overwrite? [y/N] "
      read -r answer < /dev/tty
    else
      # Non-interactive (curl | bash) — skip overwrite by default
      echo "  File exists: $1 — skipping (non-interactive)"
      answer="N"
    fi
    if [ "$answer" != "y" ] && [ "$answer" != "Y" ]; then
      echo "  Skipped: $1"
      return
    fi
  fi

  cat > "$filepath"
  echo "  Created: $1"
}

# Helper: write a file and make it executable
write_executable() {
  write_file "$1"
  chmod +x "$TARGET_DIR/$1"
}

HEADER

# Now iterate through all scaffold files and generate heredoc blocks
# Use null-delimited find + sort for filename safety (spaces, special chars)
while IFS= read -r -d '' filepath; do
  # Get relative path from scaffold/
  relpath="${filepath#$SCAFFOLD_DIR/}"

  # Determine the output filename (strip .template extension)
  outpath="$relpath"
  if [[ "$relpath" == *.template ]]; then
    outpath="${relpath%.template}"
  fi

  # Determine if it should be executable
  is_executable=false
  case "$relpath" in
    *.sh) is_executable=true ;;
    .husky/*) is_executable=true ;;
  esac

  # Use a unique delimiter for heredoc to avoid conflicts
  delimiter="SCAFFOLD_EOF_$(echo "$relpath" | tr '/.' '__' | tr '[:lower:]' '[:upper:]')_7f3d9a"

  if [ "$is_executable" = true ]; then
    echo "write_executable '$outpath' << '$delimiter'" >> "$OUTPUT"
  else
    echo "write_file '$outpath' << '$delimiter'" >> "$OUTPUT"
  fi

  cat "$filepath" >> "$OUTPUT"
  echo "" >> "$OUTPUT"
  echo "$delimiter" >> "$OUTPUT"
  echo "" >> "$OUTPUT"
done < <(find "$SCAFFOLD_DIR" -type f -print0 | sort -z)

# Add the package.json gates script setup
cat >> "$OUTPUT" << 'FOOTER'

# Set up the gates script in package.json
setup_gates() {
  local run_cmd="npm run"
  if [ "$PKG_MANAGER" = "pnpm" ]; then
    run_cmd="pnpm"
  elif [ "$PKG_MANAGER" = "yarn" ]; then
    run_cmd="yarn"
  fi

  if [ ! -f "$TARGET_DIR/package.json" ]; then
    echo ""
    echo "Creating package.json with gates script..."

    cat > "$TARGET_DIR/package.json" << PKGJSON
{
  "name": "my-project",
  "version": "0.0.1",
  "private": true,
  "scripts": {
    "dev": "echo 'Add your dev command'",
    "lint": "biome check .",
    "typecheck": "tsc --noEmit",
    "test": "vitest run",
    "build": "echo 'Add your build command'",
    "gates": "$run_cmd lint && $run_cmd typecheck && $run_cmd test && $run_cmd build"
  }
}
PKGJSON
    echo "  Created: package.json"
  else
    echo ""
    echo "package.json already exists. Add this script manually:"
    echo ""
    echo "  \"gates\": \"$run_cmd lint && $run_cmd typecheck && $run_cmd test && $run_cmd build\""
    echo ""
  fi
}

setup_gates

# Map package manager to install/run/exec commands for next-steps output
case "$PKG_MANAGER" in
  pnpm)
    PM_INSTALL="pnpm add -D"
    PM_EXEC="pnpm dlx"
    PM_RUN="pnpm"
    ;;
  yarn)
    PM_INSTALL="yarn add --dev"
    PM_RUN="yarn"
    # yarn dlx only exists in Yarn v2+ (Berry); Yarn v1 (Classic) needs npx
    if yarn --version 2>/dev/null | grep -q '^1\.'; then
      PM_EXEC="npx"
    else
      PM_EXEC="yarn dlx"
    fi
    ;;
  *)
    PM_INSTALL="npm install --save-dev"
    PM_EXEC="npx"
    PM_RUN="npm run"
    ;;
esac

echo ""
echo "✓ Scaffold initialized in $TARGET_DIR"
echo ""
echo "Next steps:"
echo "  1. Edit CLAUDE.md — replace all [bracketed] values"
echo "  2. Edit .env.example — add your environment variables"
echo "  3. Edit .claude/settings.json — adjust allowed commands"
echo "  4. Run: $PM_INSTALL husky && $PM_EXEC husky init"
echo "  5. Run: $PM_RUN gates (verify everything passes)"
echo ""
echo "Optional:"
echo "  - Edit NOW.md if project will last > 2 weeks"
echo "  - Edit AGENTS.md if project exposes an API"
echo "  - Delete files you don't need (see docs/DECISION-TREES.md)"
FOOTER

chmod +x "$OUTPUT"
echo "✓ Generated: $OUTPUT"
echo "  File count: $(find "$SCAFFOLD_DIR" -type f | wc -l | tr -d ' ') files inlined"
